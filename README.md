[![version](http://img.shields.io/badge/version-v0.0.1-blue.svg)](#)
[![versioning](http://img.shields.io/badge/versioning-semver-blue.svg)](http://semver.org/)
[![CircleCI](https://circleci.com/gh/travismcchesney/mail-it.svg?style=shield)](https://circleci.com/gh/travismcchesney/mail-it)

# Mail It <sub><sup>| Provider agnostic email-o-matic</sup></sub>

## Building

If you want to build it, you'll first need to have `java sdk >= 1.8.0` and `maven >= 3.2.5`.

Then, run `mvn package` to build and package up the application.

## Testing

Run `mvn test` to run the unit tests.

## Configuring

### Environment Variables

The first (recommended) way to configure the application is with the following environment variables:
* `DW_MAIL_PROVIDER`   : Specify the email provider to use. One of `sendgrid` or `mailgun`. If omitted, `sendgrid` is
 the
default
* `DW_MAILGUN_API_KEY` : Specify the Mailgun API key, if applicable
* `DW_SENDGRID_API_KEY`: Specify the Sendgrid API key, if applicable

### Config File

Alternatively, you can update the `config.yml` file to set the configuration values:
* `mailProvider`  : Specify the email provider to use. One of `sendgrid` or `mailgun`.
* `mailgunApiKey` : Specify the Mailgun API key, if applicable
* `sendgridApiKey`: Specify the Sendgrid API key, if applicable

## Starting

Once configured, Mail It can be started locally using either the fat Jar generated by the `Building` step above, or by
using the pre-built docker container.

### Jar

The `jar` contains everything needed to run the application. Simply start it like so:

`java -jar target/mailit-0.0.1.jar server config.yml`

> NOTE: Either environment variables or config.yml configuration work when running with java

### Docker

The docker image also contains everything needed to run the application. Simply start it like so:

```
docker run -d \
 --name mailit --rm \
 -p 8080:8080 -p 8081:8081 \
 -e "DW_MAIL_PROVIDER=mailgun" \
 -e "DW_MAILGUN_API_KEY=<mailgun-api-key>" \
 travismcchesney/mailit:0.0.1
```

> NOTE: Environment variables are required when running with docker

## Using

If running locally with the Jar or docker, the application can now be used at `http://localhost:8080`

To try things out without running locally, use `https://mailit.travis.technology`.

## Monitoring

To inspect the health of the application, navigate to `http://localhost:8081/healthcheck`

## Examples

```bash
curl -X POST \
  http://localhost:8080/email \
  -H 'Content-Type: application/json' \
  -d '{
	"to": "jack@example.com",
	"to_name": "Jack",
	"from": "noreply@paperstreetsoapco.com",
	"from_name": "Tyler Durden",
	"subject": "A Message from Paper Street Soap Co.",
	"body": "<h1>Your Bill</h1><p>$10</p>"
}'
```

## API Documentation

Documentation for the email API endpoint can be found at `/swagger`.

## Docker

To build the docker container for a new version, first run an `mvn package`, then run from the project root:

`docker build -t <repo>/mailit:<version> .`

`docker push <repo>/mailit:<version>`

## Notes

### Language, Framework, Libraries

My first inclination was to use something like Express with Node.js, as you can get up and running with minimal
dependencies and time. However, given the requirement to show good OO principles, I decided against that route, as it
 would definitely be more functional in nature.
I landed on using Java with Dropwizard. Java is my strongest OO language at the moment, and Dropwizard was a natural
fit for the task. Things I looked at with Dropwizard were 1) great documentation, 2) decently large community, 3)
speed, 4) metrics and monitoring capabilities, and 4) getting going with pretty minimal effort.

As for additional libraries, I tried to keep them to a minimum where possible, and use the built-in functionality of
the Jersey libraries that are provided in Dropwizard.

I leveraged Swagger for API documentation, as it has a really robust tool set and can easily be integrated with
Dropwizard. Unfortunately, it looks like the package is causing some class loader warnings which, given more time, I'd
look into further.

Maven is used for building/packaging as it's a natural fit for Java/Dropwizard, and has been around for ages so
there's plenty of documentation, support, and tooling.

### Tradeoffs

Firstly, for these minimal requirements, something like Dropwizard or Spring Boot would be a bit overkill, and I'd
probably tend toward a Node.js application with a smaller footprint. That said, it's hard to know where an
application is going to go, so it might be beneficial to have a larger, more flexible framework backing it as things
move forward.

Given additional time, I would have liked to complete the individual health checks for each provider. I wired in the
health checks for them, but they're hard coded to be healthy. I was envisioning making an API call either to an API
endpoint that the provider exposes, or to a third party API like StatusPage that could tell me if something was
degraded. With that, it would be trivial to then alert on the health endpoint noticing that the provider might be in
a degraded state and fail over gracefully, without much, if any, human intervention.

Also with more time, I would love to build out the monitoring around the metrics that Dropwizard exposes. There are
all sorts of useful data points in there that would be great to get onto a dashboard with alerts at certain thresholds.

I've chosen to use a simple factory pattern for creating the proper mail provider instance, but I would consider
using a more full featured dependency injection framework if things were to get much more complex.

### Additional

I leveraged Jackson for input validation handling rather than using a separate validator class. No need to reinvent the
wheel here. Any missing fields on the incoming Mail object will be listed, and the response status will be `422
Unprocessable Entity`.

I'm using CircleCI for continuous testing of the codebase, which is also integrated into the GitHub PR process.

I'm using unit testing throughout, with mocking where necessary. I feel the unit test coverage is pretty solid, but
I have not done much in the way of integration testing. My thinking here is that my mocks in the unit tests go right
up to the service boundary, so there's likely pretty minimal ROI with integration testing or using something like
wiremock to mock out the endpoint. That said, with a bit more time I would definitely add integration tests, because
they do have value in keeping the code in a healthy, quality state.
