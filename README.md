[![version](http://img.shields.io/badge/version-v0.0.1-blue.svg)](#)
[![versioning](http://img.shields.io/badge/versioning-semver-blue.svg)](http://semver.org/)
[![CircleCI](https://circleci.com/gh/travismcchesney/mail-it.svg?style=shield)](https://circleci.com/gh/travismcchesney/mail-it)

# Mail It <sub><sup>| Provider agnostic email-o-matic</sup></sub>

## Building

If you want to build it, you'll first need to have `java sdk >= 1.8.0` and `maven >= 3.2.5`.

Then, run `mvn package` to build and package up the application.

> NOTE: If you don't want to build it, there is a docker image available (see the [Docker](#docker) section below)

## Testing

Run `mvn test` to run the unit tests.

## Configuring

In order to select which email provider to use for sending email, there are two options:

### Environment Variables

The first (recommended) way to configure the application is with the following environment variables:
* `DW_MAIL_PROVIDER`   : Specify the email provider to use. One of `sendgrid` or `mailgun`. If omitted, `sendgrid` is
 the default
* `DW_MAILGUN_API_KEY` : Specify the Mailgun API key, if applicable
* `DW_SENDGRID_API_KEY`: Specify the Sendgrid API key, if applicable

### Config File

Alternatively, you can update the `config.yml` file to set the configuration values:
* `mailProvider`  : Specify the email provider to use. One of `sendgrid` or `mailgun`.
* `mailgunApiKey` : Specify the Mailgun API key, if applicable
* `sendgridApiKey`: Specify the Sendgrid API key, if applicable

## Starting

Once configured, Mail It can be started locally using either the fat Jar generated by the [Building](#Building) step
above, or by using the pre-built docker container.

### Jar

The `jar` contains everything needed to run the application. Simply start it like so (with mailgun, for example):

```
DW_MAIL_PROVIDER=mailgun \
DW_MAILGUN_API_KEY=<mailgun-api-key> \
java -jar target/mailit-0.0.1.jar server config.yml
```

> NOTE: Either environment variables or config.yml configuration work when running with java. If you're going to run
> without environment variables, be sure to update the `config.yml` first

### Docker

The docker image also contains everything needed to run the application. Simply start it like so:

```
docker run -d \
 --name mailit --rm \
 -p 8080:8080 -p 8081:8081 \
 -e "DW_MAIL_PROVIDER=mailgun" \
 -e "DW_MAILGUN_API_KEY=<mailgun-api-key>" \
 travismcchesney/mailit:0.0.1
```

> NOTE: Environment variables are required when running with docker

## Using

If running locally with the jar or docker image, the application can now be used at `http://localhost:8080`

To try things out without running locally, the app is deployed and accessible at `https://mailit.travis.technology`.

## Monitoring

To inspect the health of the application, navigate to `http://localhost:8081/healthcheck`

## Examples

```bash
curl -X POST \
  http://localhost:8080/email \
  -H 'Content-Type: application/json' \
  -d '{
	"to": "jack@example.com",
	"to_name": "Jack",
	"from": "noreply@paperstreetsoapco.com",
	"from_name": "Tyler Durden",
	"subject": "A Message from Paper Street Soap Co.",
	"body": "<h1>Your Bill</h1><p>$10</p>"
}'
```

## API Documentation

Documentation for the email API endpoint can be found at `/swagger`.

## Publishing a Docker Image

To build the docker container for a new version, first run an `mvn package`, then run from the project root:

`docker build -t <repo>/mailit:<version> .`

`docker push <repo>/mailit:<version>`

## Notes

### Language, Framework, Libraries

My first inclination was to use something like Express with Node.js, as you can get up and running with minimal
dependencies and time. However, given the requirement to show good OO principles, I decided against that route, as it
 would definitely be more functional in nature.
I landed on using Java with Dropwizard. Java is my strongest OO language, and Dropwizard was a natural fit for the task.
Things I looked at with Dropwizard were 1) great documentation, 2) decently large community, 3)
speed (throughput), 4) metrics and monitoring capabilities, and 5) getting going with pretty minimal effort.

As for additional libraries, I tried to keep them to a minimum where possible, and use the built-in functionality of
the Jersey libraries that are provided in Dropwizard.

I leveraged Swagger for API documentation, as it has a really robust tool set and can easily be integrated with
Dropwizard.

Maven is used for building and packaging the application, as it's a solid choice for Java/Dropwizard, and has been
around for ages so there's plenty of documentation, support, and tooling.

### Tradeoffs

Firstly, for these minimal requirements, something like Dropwizard or Spring Boot would be a bit overkill, and I'd
probably tend toward a Node.js application with a smaller footprint. That said, it's hard to know where an
application is going to go, so it might be beneficial to have a larger, more flexible framework backing it as things
move forward.

Given additional time, I would have liked to complete the individual health checks for each provider. I wired in the
health checks for them, but they're hard coded to be healthy. I was envisioning making an API call either to an API
endpoint that the provider exposes, or to a third party API like StatusPage that could tell me if something was
degraded. With that, it would be trivial to then alert on the health endpoint noticing that the provider might be in
a degraded state and fail over gracefully, without much, if any, human intervention.

Also with more time, I would love to build out the monitoring around the metrics that Dropwizard exposes. There are
all sorts of useful data points in there that would be great to get onto a dashboard with alerts at certain thresholds.

I've chosen to use a simple factory pattern for creating the proper mail provider instance, but I would consider
using a more full featured dependency injection framework if things were to get much more complex.

Error handling is another area on which I'd like to spend more time. The response from the provider endpoint is
currently only verified to have a success response code (200-299). If it's not, then an error is returned to the user
with the response body from the endpoint. A more thorough examination of the possible error responses from the endpoint
is necessary in order to fully communicate problems with consumers of the application.

Lastly, both the docker build/push and `now` deployment could be automated in a continuous deployment process. With
more time, that would be a big win to reduce developer toil.

### Additional

I leveraged Jackson for input validation handling rather than using a separate validator class. No need to reinvent the
wheel here. Any missing fields on the incoming Mail object will be listed, and the response status will be `422
Unprocessable Entity`.

I'm using CircleCI for continuous testing of the codebase, which is also integrated into the GitHub PR process.

JUnit is used for unit testing throughout, with mocking where necessary. I feel the unit test coverage is pretty solid,
but I have not done much in the way of integration testing. The mocks in the unit tests go right up to the service
boundary, so there's likely pretty minimal ROI with full integration testing or using something like wiremock to mock
out the endpoint at this stage. That said, with a bit more time, and in a production codebase, I would definitely add
integration tests, because they do have value in keeping the code in a healthy, quality state.

### Bonus

I tried to go a bit beyond the requirements by getting the application running in a Docker container and deployed to
Zeit's `now` service, so it's publicly available to try.

Additionally, rather than updating a configuration file (which you can still do), I implemented the ability to leverage
environment variables for configuration. I find this to be a more flexible option, especially when deploying to things
like Docker and Kubernetes.
